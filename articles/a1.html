<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel ="stylesheet" href="article.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
<title>Եռաչափ տարածության պատկերումը</title>

</head>

<body>
<nav class="navbar">
<a class="logo" href="https://hamletpetrosyan.github.io/erankyun">3անկյուն</a>
<ul class="nav-links">
<li><a href="https://hamletpetrosyan.github.io/erankyun/index.html">Բլոգ</a></li>
<li><a href="https://hamletpetrosyan.github.io/erankyun/articles.html">Հոդվածներ</a></li>
<li><a href="#">Իմ մասին</a></li>
</ul>
</nav>

<div class="container">
<div class="content">
<header id="title-block-header">
<h1 class="title">Եռաչափ տարածության պատկերումը</h1>
<p class="info">Համլետ Պետրոսյան
</h6>
<p class="info">18.04.2022
</h6>
</header>
<h1 id="ներածություն">Ներածություն</h1>
<h2 id="հիմնական-գաղափարը">Հիմնական գաղափարը</h2>
<p>Մենք մեզ շրջապատող աշխարհը ընկալում ենք որպես եռաչափ տարածություն։
Մարդը դարեր շարունակ ուսումնասիրել է իր շուրջը իրականացող երևույթները,
փորձել գտնել օրինաչափություններ։ Դրանք օգտագործելով՝ նկարիչները
վարպետորեն վրձնել են ավելի ու ավելի իրականին մոտ պատկերներ։ Իսկ 20-րդ
դարի երկրորդ կեսում, երբ հնարավորություն առաջացավ արագ հաշվարկներ
կատարելու և որոշակի արդյունքներ ցուցադրելու էկրանին, ի հայտ եկավ
ինքնուրույն հաշվարկներով եռաչափ տարածություններ պատկերելու
ցանկություն։</p>
<p>Մարդուն որևէ ինֆորմացիա հաղերդելու համար սարքերը մեծամասամբ
օգտագործում են էկրան։ Այս դեպքը ևս բացառություն չէ։ Եռաչափ տարածության
մասին պատկերացումը մեզ տրվում է էկրանի միջոցով։ Սովորական էկրանը իրենից
ներկայացնում է իրար կողք շարված մասնիկներից(պիքսելներից) կազմված
ուղանկյուն։ Յուրաքանչյուր պիքսել որոշվում է ընդամենը երկու բնութագրող
թվերով՝ տողի և սյան համարներով։ Հետևաբար էկրանի դեպքում, եթե անտեսենք
նրա՝ մեզ չհետաքրքրող ֆիզիկական չափերը, գործ կունենանք երկչափ օբյեկտի
հետ։ Երկչափ օբյեկտներ են նաև նկարները և լուսանկարները։ Եռաչափ
տարածությունը պատկերվում է երկչափի մեջ, իսկ դիտողը մտքում ինքնուրույն
վերստեղծում է եռաչափ տարբերակը։</p>
<h2 id="տարածության-մարդու-ընկալումը">Տարածության մարդու ընկալումը</h2>
<p>Էկրանի միջոցով անհրաժեշտ է տալ ինֆորմացիա, որը դիտողը կնմանեցնի
եռաչափ տարածության։ Նախ հասկանանք, որ մեզ հասանելի միակ գործիքը
պիքսելներն են, որոնք կարող են ցույց տալ որոշակի գույն։ Մեր գլխավոր
նպատակը հենց այդ գույները հաշվարկելն է։ Այժմ ուսումնասիրենք իրական
մոդելը՝ ֆիզիկական բացատրությունների մեջ չխորանալով:</p>
<div class="center">
<p><img src="images\a1\pic1.png" /></p>
</div>
<p>Տարածության մեջ կա լույսի աղբյուր, որը արձակում է որոշակի ուղղությամբ
լույսի ճառագայթներ։ Հիմնական լույսի աղբյուրը մեզ համար հանդիսանում է
արևը, բայց լույսի աղբյուրներ կարող են լինել կրակը, լամպը, որոշ
լուսարձակող նյութեր(օրինակ՝ ֆոսֆոր) և այլն։ Այդ արձակված ճառագայթները
տարածվում են, որոշները հանդիպում այլ մարմինների։ Մարմինների բախվելիս
ճառագայթները որոշ չափով կլանվում են, անդրադառնում մարմնի մակերևույթից,
բաժանվում մասերի և ցրվում տարբեր ուղղություններով։ Յուրաքանչյուր
բախումից հետո ճառագայթները փոխում են հատկանիշները, ինչի շնորհիվ էլ
դառնում են ավելի թույլ, գունափոխվում։ Եվ վերջապես այդ ճառագայթներից
որոշները հայտնվում են մեր տեսողական ընկալիչում՝ աչքում, որի շնորհիվ էլ
առաջանում է մեզ հասանելի պատկերը։</p>
<h2 id="դասական-լուսանկարչական-սարքի-աշխատանքը">Դասական լուսանկարչական
սարքի աշխատանքը</h2>
<p>Քանի որ լուսանկարչությունը այս թեմային շատ մոտ ոլորտ է, ավելորդ չի
լինի որոշակի պատկերացում ունենալ նաև լուսանկարչական սարքերի աշխատանքի
մասին։ Պարզության համար դիտարկենք անդրանիկ սարքերի աշխատանքը։</p>
<div class="center">
<p><img src="images\a1\pic2.png" /></p>
</div>
<p>Ունենք ֆոտոխցիկ, որի մի պատին տեղադրված է նյութը, որն իր վրա պետք է
պահպանի պատկերը, իսկ արկղի՝ դրան հանդիպակաց պատին արված է անցք։ Այդ
անցքի միջով անցնելով լույսի ճառագայթները ընկնում են հատուկ նյութի վրա և
քիմիական ռեակցիայի միջոցով փոխում գույնը։ Արդյունքում ստացվում է շրջված
և աջը ձախի փոխված պատկերը։ Արկղի լուսանցքի հեռավորությունը և մեծությունը
որոշում են լուսանկարի լուսավորության չափը, ինչպես նաև ֆոկուսավորման
հեռավորությունը։ Հենց սա էլ բացատրում է անցքի գոյությունը։ Եթե հատուկ
նյութը դրվեր բոլորովին բաց միջավայրում, ապա բոլոր կողմերից լույս
կընկներ, և լույսի ավելցուկից կստանայինք միագույն սպիտակ լուսանկար։</p>
<h2 id="համակարգչային-տարբերակը">Համակարգչային տարբերակը</h2>
<p>Այժմ եթե փորձենք ամբողջովին վերարտադրել իրական տարբերակը, կբախվենք
խնդրի, որ լույսի աղբյուրներից բավականին շատ ճառագայթներ ենք բաց թողնում,
իսկ դրանց մեծամասնությունը նույնիսկ աչքի մեջ չի ընկնում։ Քանի որ մեզ
հետաքրքրում են միայն այն ճառագայթները, որոնք հայտնվելու են աչքում կամ
ֆոտոխցիկում, ապա հանգենք այն մտքին, որ ճառագայթները բաց թողենք հենց
ֆոտոխցիկից։ Մեր գործը հեշտացնելու համար էկրանը կարող ենք տեղադրել
ֆոտոխցիկի դիմաց որոշ հեռավորությամբ, քանի որ այսպես կազատվենք ֆոկուս
ընտրելու, պատկերը շրջելու խնդիրներից։ Իսկ ինչը վերաբերվում է
ճառագայթներին, կարծես թե բավարար է յուրաքանչյուր պիքսելի
համապատասխանեցնել ֆոտոխցիկից իրեն ձգվող ճառագայթը և դրանից եզրակացնել իր
գույնը։</p>
<div class="center">
<p><img src="images\a1\camera.png" /></p>
</div>
<p>Քանի որ անձամբ դիտորդն էլ էկրանին նայում է որոշակի հեռավորությունից,
այս մեթոդը բավականին իրականին մոտ արդյունք է վերադարձնում։</p>
<h1 id="աշխատանքային-միջավայրը">Աշխատանքային միջավայրը</h1>
<h2 id="windows-ում-պատուհանի-ստեղծում">Windows-ում պատուհանի
ստեղծում</h2>
<p>Առաջին հերթին անհարժեշտ է ստեղծել պատուհան։ Այդ առաջադրանքը
հեշտությամբ կարելի է կատարել C++ լեզվի օգնությամբ, քանի որ այն աչքի է
ընկնում իր արագագործությամբ և բավականին լավ հնարավորություններ է
ընձեռում Windows օպերացիոն համակարգով աշխատելու համար։ C++ լեզվում
գոյություն ունի Windows.h գրադարանը, որը նախատեսված է հենց նույնանուն
օպերացիոն համակարգի համար, և թույլ է տալիս հեշտությամբ ստեղծել պատուհան,
բայց պիքսելների հետ աշխատելու համար անհրաժեշտ կլինի ինքնուրույն գրել
բավականին շատ ֆունկցիաներ։ Այդ իսկ պատճառով ավելի հարմար է օգտագործել
այդպիսի գործողությունների համար նախատեսված գրադարան, ինչպիսին է օրինակ
SFML-ը։ Գրադարանի հեղինակները այն ներկայացնում են, որպես երկչափ
պատկերներ ստանալու համար գործիքների հավաքածու, բայց նրա
հնարավորությունները մեզ չեն սահմանափակում եռաչափի պատկերման ժամանակ։</p>
<p>SFML-ի հնարավորություններից ելնելով՝ կարելի է նաև ծրագրավորել
ստեղնաշարի միջոցով շարժվելը, մկնիկի միջոցով դիտելու ուղղության
փոփոխությունը և այլ գործողություններ։ Այս ամենում ավելի չենք խորանա,
քանի որ սա հիմնական թեման չէ։</p>
<h2 id="շեյդերներ">Շեյդերներ</h2>
<p>Ժամանակի ընթացքում հաշվարկներ պահանջող գրաֆիկական էլեմենտների
ավելանալու պատճառով ստեղծվել են համակարգչին կցվող առանձին
սարքեր(գրաֆիկական քարտեր)։ Այդ քարտերը բավականին տարբերվում են հիմնական
պրոցեսորից։ Քանի որ թեման հենց գրաֆիկական պատկեր հաշվարկելու մասին է,
տրամաբանական կլինի ծրագիրը գրել հենց գրաֆիկական քարտի համար։ Այդ
նպատակով կաշխատենք շեյդերներով, որոնք այդ սարքերին հանձնարարվող ծրագրեր
են հանդիսանում։</p>
<p>Շեյդերներ գրելու հայտնի լեզուներից են GLSL (OpenGL Shading
Language)-ը և HLSL (High-Level Shading Language)-ը։ HLSL-ը բավականին
հարմարեցված է Windows-ի գրաֆիկական մաս ապահովող DirectX գրադարանի հետ
աշխատելու համար։ Բայց սեփական նախընտրությունից ելնելով՝ այս հոդվածի
շեյդերները կլինեն GLSL լեզվով։ GLSL լեզվի ֆայլերը պահպանում են .frag
վերջավորությամբ։</p>
<p>Պատկերացում կազմելու համար նշենք, որ GLSL-ում արդեն իսկ կան գրված
հաճախ օգտագործող ֆունկցիաներ(օրինակ՝ dot - վեկտորների սկալյար արտադրյալ,
normalize - վեկտորի երկարության բերում 1-ի, length - վեկտորի
երկարություն) և տվյալների կառուցվածքներ (օրինակ՝ vec2, vec3, vec4 -
իրենց համարին համապատասխան չափանի վեկտորներ)։ Նշենք նաև, որ շեյդերը
յուրաքանչյուր պիքսելի համար աշխատում է առանձին և ունի սահմանված գլոբալ
փոփոխականներ, որոնցից կօգտագործենք gl_FragColor-ը, ինչը իրենից
ներկայացնում է vec4(red, green, blue, opacity)՝ համարվելով տրված պիքսելի
գույնը, և gl_TexCoord-ը, որը պարունակում է տեղեկություն տեքստուրայի
տեղակայման մասին(SFML-ում շեյդերի ստացած պատկերը դուրս ենք բելերու
տեքստուրայի տեսքով)։ Նաև ունենք հնարավորություն uniform բանալի բառի
օգնությամբ հիմնական ծրագրից խնդրել որոշակի արժեքներ։</p>
<pre><code>uniform vec2 u_res; // window resolution

void main{
    vec3 color = vec3(1.0); // white
    gl_FragColor = vec4(color, 1.0);
} </code></pre>
<p>Տրված շեյդերի դեպքում կտեսնենք սպիտակ պատուհան, իսկ C++-ի կոնսոլային
հավելված ստեղծելու դեպքում, նաև կտեղեկացվենք, որ u_res փոփոխականը չի
օգտագործվել։</p>
<p>Յուրաքանչյուր պիքսելի սեփական ճառագայթը համապատասխանեցնելուց հետո,
անհրաժեշտ է, այդ ճառագայթն օգտագործելով, գտնել պիքսելի գույնը։ Այսինքն
հետևենք ճառագայթին և գրանցենք, թե ինչ մարմինների է բախվում։ Այդ
բախումները գրանցելու ամենատարածված տարբերակներն են Ray-Marching-ը և
Ray-Casting-ը։ Ստորև մանրամասն խոսենք դրանցից յուրաքանչյուրի մասին։</p>
<h1 id="ray-marching">Ray-Marching</h1>
<h2 id="գաղափարը">Գաղափարը</h2>
<p>Որոշելու համար, թե տրված ճառագայթը առաջինը ո՞ր մարմնի հետ կբախվի,
կատարենք հետևյալ քայլերը․</p>
<ol type="1">
<li><p>գտնենք ճառագայթի սկզբնակետի հեռավորությունները բոլոր մարմիններից
և վերցնենք դրանցից փոքրագույնը,</p></li>
<li><p>տեղափոխենք սկզբնակետը ճառագայթի ուղղությամբ և ստացված
հեռավորությամբ,</p></li>
<li><p>կրկնենք առաջին գործողությունը, քանի դեռ շատ չենք հեռացել
սկզբնական դիրքից, բավականաչափ չենք մոտեցել որևէ մարմնի, կամ չենք կատարել
առավելագույն քանակի քայլեր։</p></li>
</ol>
<div class="center">
<p><img src="images\a1\raymarch.png" /></p>
</div>
<p>Վերցնելով հեռավորություններից փոքրագույնը՝ մենք բացառում ենք, որ
ճառագայթը մինչ այդ ուրիշ մարմնի կհանդիպի։ Սկզբնական դիրքից առավելագույն
հեռավորություն սահմանելով՝ հաշվի չենք առնում դիտման կետից բավական հեռու
մարմինները, ինչը որոշ դեպքերում կարող է զգալիորեն քչացնել պահանջվող
գործողությունների քանակը։ Այժմ հասկանանք, թե ինչու չենք համարում, որ
ճառագայթը բախվել է մարմնին, միայն այն դեպքում, եթե նրանից ներկայիս
սկզբնակետի հեռավորթյունը 0 է: Նկատենք, որ եթե ճառագայթը մարմնի
մակերևույթին չընկնի ուղղահայաց, ապա սկզբնակետը անվերջ կմոտենա մարմնին,
բայց նրա հեռավորությունը մակերևույթից 0 չի դառնա: Հետևաբար ստիպված ենք
բախման հեռավորություն սահմանել։ Իսկ եթե ճառագայթը ուղղված լիներ մարմնի
մակերևույթին զուգահեռ, ապա սկզբնակետը միշտ կունենար նույն
հեռավորությունը մարմնից և անվերջ կտեղափոխվեր ճառագայթի ուղղությամբ։
Կարող է թվալ, որ առավելագույն հեռավորության սահմանումը կլուծի այս
խնդիրը, բայց սկզբնակետի մարմնին մոտ լինելու դեպքում այդպես չէ։ Հետևաբար
կսահմանենք նաև քայլերի առավելագույն քանակ։ Իհարկե, այս բոլոր
սահմանափակումները կարող են հանգեցնել որոշակի թերությունների, բայց
դեպքերի մեծամասնությունում դրանք աննշան են։</p>
<h2 id="իրականացման-օրինակ">Իրականացման օրինակ</h2>
<pre><code>// ro - ray origin, rd - ray direction

vec3 rayMarch(vec3 ro, vec3 rd) {
    vec3 pos = ro;
    float surfed = 0.0;

    for(int i = 0; i &lt; MAX_STEPS; i++) {
        float dist = getDist(p);
        surfed += dist;
        if(dist &lt; HIT_D) {
            return vec3(1.); // white
        }
        if(surfed &gt; MAX_D){
            return vec3(0.);
        }
        pos += rd * dist; // shifting start point
    }
    return vec3(0.); // black
}</code></pre>
<p>Եվ օգտագործենք այն․</p>
<pre><code>uniform vec2 u_res;
uniform vec3 u_pos; // camera position

vec3 rayMarch(vec3 ro, vec3 rd) { ... }

void main() {
    // aligning texture to center   
    vec2 uv = (gl_TexCoord[0].xy - 0.5) * u_res / u_res.y;

    vec3 rayOrigin = u_pos;
    vec3 rayDirection = normalize(vec3(1.0, uv));

    vec3 color = rayMarch(rayOrigin, rayDirection);

    gl_FragColor = vec4(color, 1.0);
}</code></pre>
<p>Տրված ֆունկցիան կվերադարձնի սպիտակ, որտեղ կա բախում, հակառակ դեպքում՝
սև։ Միակ բացը այստեղ մնում է getDist ֆունկցիան, ինչը գրելու համար
անհրաժեշտ է կարողանալ գտնել յուրաքանչյուր մարմնից հեռավորություն։</p>
<h2 id="հեռավորության-ֆունկցիաներ">Հեռավորության ֆունկցիաներ</h2>
<p>Հարմար է օգտագործել հեռավորության նշան պարունակող ֆունկցիաներ (Signed
Distance Fields), որոնց բացասական լինելու դեպքում հասկանալի է դառնում,
որ հարցում ենք կատարում մարմնի ներսից։ Նաև յուրաքանչյուր մարմնի համար
կարող ենք ստեղծել առանձին տիպ (struct), որը թույլ կտա բոլոր անհրաժեշտ
տվյալները պահել հավաք։ Ստորև որոշ օրինակներ.</p>
<ul>
<li><p>գունդ,</p>
<pre><code>// p - camera position
// Sphere(float radius, ...)
float sdSphere(vec3 p, Sphere s) {
    return length(p) - s.radius;
}</code></pre></li>
<li><p>ուղղանկյունանիստ,</p>
<pre><code>// Box(vec3 sizes, ...)
float sdBox(vec3 p, Box b) {
    vec3 q = abs(p) - b.sizes;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y,q.z)), 0.0);
}</code></pre></li>
<li><p>հարթություն,</p>
<pre><code>// Plane(vec3 normal, float height, ...)
float sdPlane(vec3 p, Plane pl) {
    // n must be normalized
    return dot(p, pl.normal) + pl.height;
}</code></pre></li>
<li><p>տոր։</p>
<pre><code>// Torus(float outRadius, float inRadius, ...)
float sdTorus(vec3 p, Torus t) {
    vec2 q = vec2(length(p.xz) - t.outRadius, p.y);
    return length(q) - t.inRadius;
}</code></pre></li>
</ul>
<p>Մնում է միայն գտնել սրանցից փոքրագույնը getDist ֆունկցիայում և որոշել
դրա գույնը:</p>
<div class="center">
<p><img src="images\a1\rm01.jpg" /></p>
</div>
<h2 id="լուսավորություն">Լուսավորություն</h2>
<p>Ինչպես երևում է վերջին նկարում, ամբողջ մարմինը ներկել ենք միևնույն
գույնով, ինչը անբնական է։ Բացակայում են ստվերը, նաև լույսը։ Դիտարկենք
դրանց ավելացման պարզ տարբերակ։</p>
<p>Ընտրենք որևէ կոորդինատներ լույսի աղբյուրի համար։ Դիտարկենք այն կետը,
որտեղ ճառագայթը բախվել է մարմնին։ Եթե այդ մակերևույթը ուղղված է դեպի
լույսի աղբյուրը, ապա այն լուսավորված է, իսկ հակառակ դեպքում՝ ոչ։
Հետևաբար կարող ենք լուսավորության մակարդակ համարել այդ կետում
մակերևույթի նորմալի և դեպի լույսի աղբյուր ձգվող միավոր վեկտորի սկալյար
արտադրյալը։ Իսկ այդ կետում կետի նորմալը կարող ենք որոշել հայտնի հնարքով։
Շարժենք այդ կետը աննշան առանձին-առանձին Ox, Oy, Oz առանցքների
ուղղություններով։ Գտնենք մակերեվույթից ունեցած հեռավորության
փոփխությունը սկզբնական կետի հետ համեմատած։ Այդ ստացված թվերը ընդունենք,
որպես վեկտորի կոորդինատներ։ Դարձնենք վեկտորը միավոր և կստանանք
հարթության նորմալը, քանի որ գտել ենք վեկտոր, որը ցույց է տալիս
հարթությունից ամենաարագ հեռանալու ուղղությունը։</p>
<pre><code>vec3 getNormal(vec3 p){
    float d = getDist(p);
    vec2 e = vec2(HIT_D, 0);
    vec3 n = d - vec3(getDist(p - e.xyy), getDist(p - e.yxy), getDist(p - e.yyx));
    return normalize(n);
}

float getLight(vec3 p){
    vec3 lightPos = vec3(8.5, -7, -7);
    vec3 l = normalize(lightPos - p);
    vec3 n = getNormal(p);
    float dif = clamp(dot(n, l), 0., 1.);
    return dif;
}</code></pre>
<div class="center">
<p><img src="images\a1\rm02.jpg" /></p>
</div>
<h2 id="գործողություններ-մարմինների-հետ">Գործողություններ մարմինների
հետ</h2>
<p>Ray-Marching-ի ալգորիթմը հնարավորություն է տալիս գտնել հեռավորություն
ոչ միայն կոնկրետ մարմնից, այլ նաև երկու հոծ մարմինների միավորումից,
նրանց հատումից, մարմնից, որից հանել ենք մեկ այլ մարմնի հետ հատումը և
այլն։ Ահա այդպիսի հնարավորություններ տվող գործողություններ․</p>
<ul>
<li><p>երկու մարմինների միավորում (երկու մարմինները իրենց դիրքերում
տեղադրելիս նույնպես ստացվում է նույն արդյունքը),</p>
<pre><code>float booleanUnion(vec3 p, Object object1, Object object2){
    float sdA = distanceObject(p, object1);
    float sdB = distanceObject(p, object2);
    return min(sdA, sdB);
}</code></pre>
<p>(Object-ը այստեղ օգտագործված է որպես որևէ մարմնի նշանակում)</p></li>
<li><p>երկու մարմինների հատում,</p>
<pre><code>float booleanIntersection(vec3 p, Object object1, Object object2){
    float sdA = distanceObject(p, object1);
    float sdB = distanceObject(p, object2);
    return max(sdA, sdB);
}</code></pre></li>
<li><p>որևէ մարմնից հանում մյուսի հետ հատումը,</p>
<pre><code>float booleanSubtraction(vec3 p, Object object1, Object object2){
    float sdA = distanceObject(p, object1);
    float sdB = distanceObject(p, object2);
    return max(-sdA, sdB);
}</code></pre></li>
</ul>
<p>Եթե min, max ֆունկցիաները փոխարինենք, որևէ սահուն(smooth - smin,
smax)համարժեքներով, կառընչվենք նկարում ձախից առաջինը պատկերվածի նման
երևույթների։</p>
<div class="center">
<p><img src="images\a1\op.jpg" /></p>
</div>
<p>Սահուն փոքրագույն վերադարձնող ֆունկցիայի օրինակ․</p>
<pre><code>float smin(float a, float b, float k){
    float res = exp(-k * a) + exp(-k * b);
    return -log(res) / k;
}</code></pre>
<h1 id="ray-casting">Ray-Casting</h1>
<h2 id="գաղափարը-1">Գաղափարը</h2>
<p>Ի տարբերություն Ray-Marching-ի, այս մեթոդի մեջ բացի մաթեմատիկական չոր
հաշվարկներից ոչինչ չկա։ Գտնելու համար, թե որ մարմնի հետ է առաջինը
բախվում ճառագայթը, հաշվարկում ենք ճառագայթի մարմինների հետ հատման
կետերը, գտնում դրանցից սկզբնակետի հեռավորություները և վերցնում
փոքրագույնը։ Այս տարբերակը ավելի է բարդացնում հաշվարկի բանաձևերը, զրկում
մարմինների հետ արագ գործողություններ կատարելու հնարավորությունից, բայց
աչքի է ընկնում իր արագագործությամբ և բարդ կառուցվածք ունեցող մարմինների
հետ համեմատաբար հեշտ աշխատելու հնարավորությամբ։ Այստեղ նաև բացակայում են
նախորդ ալգորիթմին հատուկ պատկերման թերությունները։</p>
<div class="center">
<p><img src="images\a1\raycast.png" /></p>
</div>
<p>Այս պարագայում նույնպես սահմանենք առավելագույն հեռավորություն շատ
հեռու մարմինները անտեսելու համար։ Ելնելով աշխատանքի պարզությունից՝ ուրիշ
սահմանափակումներ ներմուծելու անհրաժեշտություն չկա։</p>
<h2 id="իրականացման-օրինակ-1">Իրականացման օրինակ</h2>
<pre><code>vec3 rayCast(vec3 ro, vec3 rd) {
    float dist = getDist(ro, rd);
    if(dist == MAX_DIST) return (1.0);
    return vec3(0.0);
}</code></pre>
<p>Ինչպես նախորդ դեպքում, բերեցինք ֆունկցիայի օրինակ, որը մարմնի
բախվելիս վերադարձնում է սպիտակ գույնը, հակառակ դեպքում՝ սևը։ Այս
ֆունկցիան համեմատած Ray-Marching-ի զավեշտալիորեն հասարակ է թվում, բայց
կբախվենք հակառակին getDist ֆունկցիան իրագործելիս։</p>
<h2 id="հեռավորության-ֆունկցիաներ-1">Հեռավորության ֆունկցիաներ</h2>
<p>Ray-Casting-ի օգտագործումը դժվարացնում է նշանով հեռավորությունների
իրագործումը, և ծանոթությունը չբարդացնելու համար կհրաժարվենք դրանցից։</p>
<p>Բերենք Ray-Marching-ի համար տրված ֆունկցիաների համարժեքները․</p>
<ul>
<li><p>գունդ,</p>
<pre><code>// Sphere(float radius, ...)
vec2 sphIntersect(vec3 ro, vec3 rd, Sphere sphere) {
    float b = dot(ro, rd);
    float c = dot(ro, ro) - sphere.radius * sphere.radius;
    float h = b * b - c;
    if(h &lt; 0.0) return vec2(-1.0); // no intersection
    h = sqrt(h);
    return vec2(-b - h, -b + h); // two intersections
}</code></pre></li>
<li><p>ուղղանկյունանիստ,</p>
<pre><code>// Box(vec3 sizes, ...)
vec2 boxIntersection(vec3 ro, vec3 rd, Box b)  {
    vec3 m = 1.0 / rd;
    vec3 n = m * ro;
    vec3 k = abs(m) * b.sizes;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    float tN = max(max(t1.x, t1.y), t1.z);
    float tF = min(min(t2.x, t2.y), t2.z);
    if(tN &gt; tF || tF &lt; 0.0) return vec2(-1.0); // no intersection
    return vec2(tN, tF); // two intersections
}</code></pre></li>
<li><p>հարթություն,</p>
<pre><code>// Plane(vec3 normal, float height, ...)
float plaIntersect(vec3 ro, vec3 rd, Plane p) {
    return -(dot(ro, p.normal) + p.height) / dot(rd, p.normal);
}</code></pre></li>
<li><p>իսկ տոր պատկերելու համար անհրաժեշտ կլինի լուծել գոնե չորրորդ
կարգի հավասարում, ինչը բավականին բարդ է իրագործելը, և Ray-Casting-ի
համար տորից հեռավորության ֆունկցիան չենք ներկայացնի։</p></li>
</ul>
<h2 id="լուսավորություն-1">Լուսավորություն</h2>
<p>Ray-Casting-ում նույնպես կարող ենք կիրառել նախորդ գլխում առաջարկված
լուսավորության մոդելը: Այս պարագայում մակերևույթների նորմալները կարող
ենք հաշվարկել հստակ բանաձևերով․ շրջանագծի դեպքում կստացվի իր կենտորնից
դեպի հատման կետ ձգվող միավոր վեկտորը, ուղղանկյունանիստի դեպքում՝ իր
կենտրոնից դեպի մակերևույթ ուղղված միավոր վեկտորը, իսկ հարթության
դեպքում՝ իր սահմանման մեջ մտած վեկտորը։</p>
<p>Հիշենք, որ մարմինները ոչ միայն լուսավորվում են լույսից, այլ որոշ
դեպքերում այն կարող են անդրադարձնել։ Վերցնենք մեր ուղղության վեկտորի
անդրադարձը մակերևույթի նկատմամբ և ստուգենք, թե ինչքանով է ուղղված դեպի
լույսի աղբյուրը։ Ստացված արդյունքը իրակակին մոտեցնելու համար կարող ենք
փոքրացնել այդ լույսի բաժինը՝ այն բարձրացնելով որևէ աստիճան։</p>
<pre><code>vec3 light = normalize(vec3(-0.5, 0.75, -1.0));
float diffuse = max(0.0, dot(light, n));
float specular = pow(max(0.0, dot(reflect(rd, n), light)), 16.0);
color *= mix(diffuse, specular, 0.5);</code></pre>
<p>Մինչ այս ճառագայթի անխոչընդոտ անցման դեպքում վերադարձրել ենք սև
գույնը։ Փոխարինենք այն երկնքով։ Երկնքում ավելացնենք նաև արևանման պատկեր՝
օգտվելով մարմնից լույսի անդրադարձի համար կիրառված հնարքից։</p>
<pre><code>// light - light direction
vec3 getSky(vec3 rd, vec3 light) {
    vec3 color = vec3(0.3, 0.6, 1.0); // color of sky
    vec3 sunclr = vec3(0.95, 0.9, 1.0); // color of sun
    sunclr *= pow(max(0.0, dot(rd, light)), 16.0);
    return clamp(sunclr + clr, 0.0, 1.0); // number from 0 to 1
}</code></pre>
<div class="center">
<p><img src="images\a1\rc1.jpg" /></p>
</div>
<h2 id="գունային-կարգավորում">Գունային կարգավորում</h2>
<p>Մինչ այս եղած բոլոր նկարներում գույները այդքան էլ իրականին մոտ չեն։
Եթե ուշադրություն դարձնենք համակարգչում գույներից սևը համարվում է 0-ն,
սպիտակը’ 1-ը, իսկ դրանց միջին մոխրագույնը’ 0.5: Գործ ունենք գծային
համակարգի հետ։ Այդ տարբերակը այդքան էլ նման չէ մեր ընկալածին, այդ իսկ
պատճառով էլ խորհուրդ է տրվում կատարել գամմա կարգավորում։ Այդքան էլ
անհրաժեշտություն չկա խորանալու գամմա կարգավորման աշխատանքի մեջ, ուղղակի
նշենք, որ գույնին համապատասխանող թվերը պետք է բարձրացնենք 0.45
աստիճան։</p>
<pre><code>color.r = pow(color.r, 0.45);
color.g = pow(color.g, 0.45);
color.b = pow(color.b, 0.45);
gl_FragColor = vec4(color, 1.0);</code></pre>
<div class="center">
<p><img src="images\a1\rc2.jpg" /></p>
</div>
<h1 id="ray-tracing">Ray-Tracing</h1>
<h2 id="գաղափարը-2">Գաղափարը</h2>
<p>Մինչև հիմա բոլոր իրագործումներում բաց ենք թողել ճառագայթ, հանդիպել
առաջին բախմանը և դադարեցրել։ Բայց իրական կյանքում այդպես չէ։ Ինչպես նշել
էինք ներածությունում, լույսը բազմաթիվ բախումների է հանդիպում և փոխում իր
հատկանիշները։ Փորձենք հակառակ հերթականությամբ վերականգնել այդ
բախումները։ Այն գաղափարը, ըստ որի պետք է հետևենք ճառագայթի ընթացքին
կանվանենք Ray-Tracing:</p>
<div class="center">
<p><img src="images\a1\raytrace.png" /></p>
</div>
<p>Փորձենք կառուցել հասարակ մոդել։ Ամեն բախման ընթացքում հաշվի առնենք
լույսի կլանումը, գույնի փոփոխությունը։ Եվ եթե հանդիպենք լույսի աղբյուրի,
կանգ առնենք։ Այս պահին համարենք, որ բոլոր մարմինները հայելային են,
որպեսզի ճառագայթի ապագա ուղղությունը կարողանանք հեշտությամբ որոշել։
Ներմուծենք նաև առավելագույն անդրադարձների քանակ։ Նկատենք, որ այլևս մեզ
պետք չեն գա լույսի ու ստվերի մեր օգտագործած մոդելները, բայց որպես լույսի
աղբյուր կարող ենք շարունակել օգտագործել երկինքը։</p>
<h2 id="իրականացման-օրինակ-2">Իրականացման օրինակ</h2>
<pre><code>bool rayCast(inout vec3 ro, inout vec3 rd, inout vec3 color) {
    vec3 clr; // color of intersection object
    vec2 minIt = vec2(MAX_DIST); // minimum distance
    vec3 n; // normal
    
    // finding minimum, normal and color
    ...
    
    // Sky
    vec3 light = normalize(vec3(-0.5, 0.75, -1.0));
    if(minIt.x == MAX_DIST) {
        color *= getSky(rd, light);
        return true;
    }
    
    color *= clr;
    ro += rd * (minIt.x - 0.001);
    rd = reflect(rd, n);
    return false;
}

vec3 rayTrace(vec3 ro, vec3 rd) {
    vec3 color = vec3(1.0);
    for(int i = 0; i &lt;= MAX_DEPTH; i++){
        if(rayCast(ro, rd, color)){
            return color;
        }
    }
    return color;
}</code></pre>
<p>rayCast ֆունկցիային փոփոխականները տալիս ենք inout տեսքով, որպեսզի նա
ստանա դրանց հասցեները։ Ավելի մանրամասն այս ամենի մասին գրված է GLSL
լեզվի պաշտոնական կայքում։ Ահա գամմա կարգավորմամբ ստացված պատկերը
(MAX_DEPTH = 30).</p>
<div class="center">
<p><img src="images\a1\rt1.jpg" /></p>
</div>
<h2 id="նյութերի-տեսակներ">Նյութերի տեսակներ</h2>
<p>Բացի հայելային նյութերից, գոյություն ունեն փայլատ, մետաղական փայլով և
այլ հատկանիշներով նյութեր։ Չբարդացնելու համար համարենք, որ նյութերը
ունեն մեկ հատկանիշ, թե ինչքան են փայլում։ Իրական կյանքում նյութերի
փայլատ լինելը որոշում է նրանց մակերևույթի խորդուբորդությունը։ Ճառագայթը,
ընկնելով այդպիսի մարմնի վրա, անդրադառնում է մեզ համար անորոշ
ուղղությամբ։</p>
<div class="center">
<p><img src="images\a1\payl.png" /></p>
</div>
<p>Եթե փորձենք այդ ամենը վերարտադրել մեր ծրագրում, ապա ճառագայթը այդպիսի
մարմնի վրա ընկնելուց հետո պետք է անդրադարձնենք պատահական ուղղությամբ։
Այս ամենը իրագործելու համար սահմանենք նյութի մոդել․</p>
<pre><code>struct Material {
    vec3 color;
    bool light;
    float roughness;
};</code></pre>
<p>որտեղ roughness-ը կարտահայտի խորդուբորդության չափը, կլինի [0; 1]
միջակայքի թիվ և ցույց կտա, թե հայելային անդրադարձված ճառագայթը ինչքանով
ենք շեղելու դեպի պատահական ընտրվածը։</p>
<pre><code>vec3 spec = reflect(rd, n);
vec3 diff = normalize(dot(n, randomOnSphere()) * randomOnSphere());
rd = mix(spec, diff, material.roughness); // reflected ray</code></pre>
<p>Աշխատեցնենք ծրագիրը և կստանանք նմանատիպ պատկեր․</p>
<div class="center">
<p><img src="images\a1\rt2.jpg" /></p>
</div>
<h2 id="path-tracing">Path-Tracing</h2>
<p>Ինչպես տեսանք վերջին նկարում պատահական ճառագայթների պատճառով փայլատ
մակերևույթներին առաջանում է աղմուկ։ Աղմուկների դեմ պայքարելու համար
գոյություն ունեն բազմաթիվ միջոցներ։ Ուսումնասիրենք Ray-Tracing-ի
տարատեսակ դարձած Path-Tracing-ը։ Հիշենք, որ յուրաքանչյուր պիքսելին
համապատասխանեցրել ենք ընդամենը մեկ ճառագայթ։ Այս տարատեսակում
առաջարկվում է յուրաքանչյուր պիքսելի համար բաց թողնել բազմաթիվ
ճառագայթներ, քանի որ դրանց պատահական անդրադարձումները կտարբերվեն, ինչի
շնորհիվ էլ կտարբերվեն նաև նրանցից ստացված արդյունքները։ Պիքսելը կներկենք
այդ ճառագայթներից ստացված գույների միջինով։ Կախված մեկ պիքսելին
համապատասխանեցված ճառագայթների թվի մեծացումից արդյունքը կսկսի
բարելավվել։</p>
<div class="center">
<p><img src="images\a1\rt3.jpg" /></p>
</div>
<p>RAY_COUNT = 100</p>
<h1 id="ամփոփում">Ամփոփում</h1>
<p>Եվ վերջապես, ստացված ծրագրի իրականին մոտ լինելը համոզվելու համար,
փորձենք ստանալ Կորնելյան համալսարանի հանրահայտ կորնելյան արկղը։</p>
<div class="center">
<p><img src="images\a1\cornell2.png" /></p>
</div>
<p>MAX_DEPTH = 64, RAY_COUNT = 64, օգտագործվել է նաև ստացված բազմաթիվ
պատկերների միջինացում(Բոլոր պատկերներին համապատասխան շեյդերները
հղումներում նշվածGitHub-ում)։</p>
<h1 id="հղումներ">Հղումներ</h1>
<p>GitHub - https://github.com/HamletPetrosyan/3dExamples</p>
<h2 id="օգտագործված-նյութերը">Օգտագործված նյութերը</h2>
<ol type="1">
<li><p>Youtube Onigiri -
https://www.youtube.com/channel/UCzdmz_lLWT_dPqOvFjXAMVg</p></li>
<li><p>Inigo Quilez blog “3D SDFs” -
https://iquilezles.org/articles/distfunctions/</p></li>
<li><p>Wikipedia - Gamma correction -
https://en.wikipedia.org/wiki/Gamma_correction</p></li>
<li><p>Random -
https://cseweb.ucsd.edu/classes/sp17/cse168-a/CSE168_07_Random.pdf</p></li>
</ol>
<h2 id="այլ-հղումներ">Այլ հղումներ</h2>
<ol type="1">
<li><p>CodeBlocks [IDE] - https://www.codeblocks.org/</p></li>
<li><p>SFML [Գրաֆիկական գրադարան] - https://www.sfml-dev.org/</p></li>
<li><p>GLSL [Շեյդերի լեզու] -
https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)</p></li>
<li><p>LaTeX [Գրանշանային լեզու] -
https://www.latex-project.org/</p></li>
<li><p>ArmTeX [LaTeX-ում հայերեն գրելու հնարավորթություն] -
https://www.ctan.org/pkg/armtex</p></li>
<li><p>MiKTeX [LaTeX-ի գործիքների հավաքածու] -
https://miktex.org/</p></li>
</ol>
</div>
<div class="menu">
<h2>Բովանդակություն</h2>
<ul>
<li><a href="#ներածություն" id="toc-ներածություն">Ներածություն</a>
<ul>
<li><a href="#հիմնական-գաղափարը" id="toc-հիմնական-գաղափարը">Հիմնական
գաղափարը</a></li>
<li><a href="#տարածության-մարդու-ընկալումը"
id="toc-տարածության-մարդու-ընկալումը">Տարածության մարդու
ընկալումը</a></li>
<li><a href="#դասական-լուսանկարչական-սարքի-աշխատանքը"
id="toc-դասական-լուսանկարչական-սարքի-աշխատանքը">Դասական լուսանկարչական
սարքի աշխատանքը</a></li>
<li><a href="#համակարգչային-տարբերակը"
id="toc-համակարգչային-տարբերակը">Համակարգչային տարբերակը</a></li>
</ul></li>
<li><a href="#աշխատանքային-միջավայրը"
id="toc-աշխատանքային-միջավայրը">Աշխատանքային միջավայրը</a>
<ul>
<li><a href="#windows-ում-պատուհանի-ստեղծում"
id="toc-windows-ում-պատուհանի-ստեղծում">Windows-ում պատուհանի
ստեղծում</a></li>
<li><a href="#շեյդերներ" id="toc-շեյդերներ">Շեյդերներ</a></li>
</ul></li>
<li><a href="#ray-marching" id="toc-ray-marching">Ray-Marching</a>
<ul>
<li><a href="#գաղափարը" id="toc-գաղափարը">Գաղափարը</a></li>
<li><a href="#իրականացման-օրինակ"
id="toc-իրականացման-օրինակ">Իրականացման օրինակ</a></li>
<li><a href="#հեռավորության-ֆունկցիաներ"
id="toc-հեռավորության-ֆունկցիաներ">Հեռավորության ֆունկցիաներ</a></li>
<li><a href="#լուսավորություն"
id="toc-լուսավորություն">Լուսավորություն</a></li>
<li><a href="#գործողություններ-մարմինների-հետ"
id="toc-գործողություններ-մարմինների-հետ">Գործողություններ մարմինների
հետ</a></li>
</ul></li>
<li><a href="#ray-casting" id="toc-ray-casting">Ray-Casting</a>
<ul>
<li><a href="#գաղափարը-1" id="toc-գաղափարը-1">Գաղափարը</a></li>
<li><a href="#իրականացման-օրինակ-1"
id="toc-իրականացման-օրինակ-1">Իրականացման օրինակ</a></li>
<li><a href="#հեռավորության-ֆունկցիաներ-1"
id="toc-հեռավորության-ֆունկցիաներ-1">Հեռավորության ֆունկցիաներ</a></li>
<li><a href="#լուսավորություն-1"
id="toc-լուսավորություն-1">Լուսավորություն</a></li>
<li><a href="#գունային-կարգավորում"
id="toc-գունային-կարգավորում">Գունային կարգավորում</a></li>
</ul></li>
<li><a href="#ray-tracing" id="toc-ray-tracing">Ray-Tracing</a>
<ul>
<li><a href="#գաղափարը-2" id="toc-գաղափարը-2">Գաղափարը</a></li>
<li><a href="#իրականացման-օրինակ-2"
id="toc-իրականացման-օրինակ-2">Իրականացման օրինակ</a></li>
<li><a href="#նյութերի-տեսակներ" id="toc-նյութերի-տեսակներ">Նյութերի
տեսակներ</a></li>
<li><a href="#path-tracing" id="toc-path-tracing">Path-Tracing</a></li>
</ul></li>
<li><a href="#ամփոփում" id="toc-ամփոփում">Ամփոփում</a></li>
<li><a href="#հղումներ" id="toc-հղումներ">Հղումներ</a>
<ul>
<li><a href="#օգտագործված-նյութերը"
id="toc-օգտագործված-նյութերը">Օգտագործված նյութերը</a></li>
<li><a href="#այլ-հղումներ" id="toc-այլ-հղումներ">Այլ հղումներ</a></li>
</ul></li>
</ul>
</div>
</div>  

<div class="footer-container">
<div class="footer-content">
<div class="footer-text">
<p>© 2023 Համլետ Պետրոսյան</p>
</div>
<div class="footer-icons">
<a href="https://codeforces.com/profile/erankyun" class="fas fa-paw"></a>
<a href="https://atcoder.jp/users/HamletPetrosyan" class="fas fa-horse"></a>
<a href="https://www.codechef.com/users/hamazark" class="fas fa-utensils"></a>
<a href="https://typingstats.com/profile/pjr" class="fas fa-keyboard"></a>
</div>
</div>
</div>
</body>

</html>